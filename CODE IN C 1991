##include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600

#define PLAYER_SPEED 5
#define BULLET_SPEED 10
#define MAX_BULLETS 10
#define MAX_ENEMIES 5
#define ENEMY_SPEED 3

#define SPRITE_WIDTH 50
#define SPRITE_HEIGHT 30
#define NUM_FRAMES 4

typedef enum { MENU, OPTIONS, PLAYING, QUIT } GameState;

typedef struct {
    int x, y;
    bool active;
} Bullet;

typedef struct {
    int x, y;
    bool active;
    SDL_Rect rect;
    int currentFrame;
} Enemy;

// Prototypes
void init_enemies(Enemy enemies[]);
bool check_collision(SDL_Rect a, SDL_Rect b);
bool render_text(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y);

int main(int argc, char *argv[]) {
    (void)argc; (void)argv;
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) {
        SDL_Log("SDL_Init failed: %s", SDL_GetError());
        return 1;
    }

    if (TTF_Init() == -1) {
        SDL_Log("TTF_Init failed: %s", TTF_GetError());
        SDL_Quit();
        return 1;
    }

    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        SDL_Log("Mix_OpenAudio failed: %s", Mix_GetError());
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    srand((unsigned int)time(NULL));

    SDL_Window *window = SDL_CreateWindow("Mini Afterburner Neo Geo Style",
                                          SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                                          WINDOW_WIDTH, WINDOW_HEIGHT, 0);
    if (!window) {
        SDL_Log("SDL_CreateWindow failed: %s", SDL_GetError());
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1,
                                               SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!renderer) {
        SDL_Log("SDL_CreateRenderer failed: %s", SDL_GetError());
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Surface *playerSurface = SDL_LoadBMP("player.bmp");
    if (!playerSurface) {
        SDL_Log("Failed to load player.bmp: %s", SDL_GetError());
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }
    SDL_Texture *playerTexture = SDL_CreateTextureFromSurface(renderer, playerSurface);
    SDL_FreeSurface(playerSurface);
    if (!playerTexture) {
        SDL_Log("Failed to create player texture: %s", SDL_GetError());
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Surface *enemySurface = SDL_LoadBMP("enemy.bmp");
    if (!enemySurface) {
        SDL_Log("Failed to load enemy.bmp: %s", SDL_GetError());
        SDL_DestroyTexture(playerTexture);
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }
    SDL_Texture *enemyTexture = SDL_CreateTextureFromSurface(renderer, enemySurface);
    SDL_FreeSurface(enemySurface);
    if (!enemyTexture) {
        SDL_Log("Failed to create enemy texture: %s", SDL_GetError());
        SDL_DestroyTexture(playerTexture);
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    TTF_Font *font = TTF_OpenFont("arial.ttf", 24);
    if (!font) {
        SDL_Log("Erreur chargement police: %s", TTF_GetError());
        SDL_DestroyTexture(enemyTexture);
        SDL_DestroyTexture(playerTexture);
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    Mix_Music *music = Mix_LoadMUS("synthwave_loop.ogg");
    Mix_Chunk *shotSound = Mix_LoadWAV("laser_shot.wav");
    Mix_Chunk *explosionSound = Mix_LoadWAV("explosion.wav");
    if (!music || !shotSound || !explosionSound) {
        SDL_Log("Erreur chargement sons: %s", Mix_GetError());
        if (music) Mix_FreeMusic(music);
        if (shotSound) Mix_FreeChunk(shotSound);
        if (explosionSound) Mix_FreeChunk(explosionSound);
        TTF_CloseFont(font);
        SDL_DestroyTexture(enemyTexture);
        SDL_DestroyTexture(playerTexture);
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    int musicVolume = MIX_MAX_VOLUME / 2;
    int effectsVolume = MIX_MAX_VOLUME / 2;

    Mix_VolumeMusic(musicVolume);
    Mix_VolumeChunk(shotSound, effectsVolume);
    Mix_VolumeChunk(explosionSound, effectsVolume);

    GameState gameState = MENU;
    SDL_Rect player = {100, WINDOW_HEIGHT / 2, SPRITE_WIDTH, SPRITE_HEIGHT};

    Bullet bullets[MAX_BULLETS] = {0};
    Enemy enemies[MAX_ENEMIES];
    init_enemies(enemies);

    bool running = true;
    SDL_Event event;

    int backgroundX = 0;
    int score = 0;

    Uint32 lastEnemyAnim = SDL_GetTicks();

    if (Mix_PlayMusic(music, -1) == -1) {
        SDL_Log("Warning: Mix_PlayMusic failed: %s", Mix_GetError());
        // Non fatal : continuer sans musique
    }

    while (running) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) running = false;
            else if (event.type == SDL_KEYDOWN) {
                switch (gameState) {
                    case MENU:
                        if (event.key.keysym.sym == SDLK_RETURN) gameState = PLAYING;
                        else if (event.key.keysym.sym == SDLK_o) gameState = OPTIONS;
                        else if (event.key.keysym.sym == SDLK_ESCAPE) running = false;
                        break;
                    case OPTIONS:
                        if (event.key.keysym.sym == SDLK_UP) {
                            musicVolume = (musicVolume + 8 > MIX_MAX_VOLUME) ? MIX_MAX_VOLUME : musicVolume + 8;
                            Mix_VolumeMusic(musicVolume);
                        }
                        if (event.key.keysym.sym == SDLK_DOWN) {
                            musicVolume = (musicVolume - 8 < 0) ? 0 : musicVolume - 8;
                            Mix_VolumeMusic(musicVolume);
                        }
                        if (event.key.keysym.sym == SDLK_LEFT) {
                            effectsVolume = (effectsVolume - 8 < 0) ? 0 : effectsVolume - 8;
                            Mix_VolumeChunk(shotSound, effectsVolume);
                            Mix_VolumeChunk(explosionSound, effectsVolume);
                        }
                        if (event.key.keysym.sym == SDLK_RIGHT) {
                            effectsVolume = (effectsVolume + 8 > MIX_MAX_VOLUME) ? MIX_MAX_VOLUME : effectsVolume + 8;
                            Mix_VolumeChunk(shotSound, effectsVolume);
                            Mix_VolumeChunk(explosionSound, effectsVolume);
                        }
                        if (event.key.keysym.sym == SDLK_ESCAPE) gameState = MENU;
                        break;
                    case PLAYING:
                        if (event.key.keysym.sym == SDLK_ESCAPE) gameState = MENU;
                        break;
                    default:
                        break;
                }
            }
        }

        if (gameState == PLAYING) {
            const Uint8 *state = SDL_GetKeyboardState(NULL);
            if (state[SDL_SCANCODE_UP]) player.y -= PLAYER_SPEED;
            if (state[SDL_SCANCODE_DOWN]) player.y += PLAYER_SPEED;
            if (state[SDL_SCANCODE_RIGHT]) player.x += PLAYER_SPEED;
            if (state[SDL_SCANCODE_LEFT]) player.x -= PLAYER_SPEED;

            if (player.y < 0) player.y = 0;
            if (player.y > WINDOW_HEIGHT - player.h) player.y = WINDOW_HEIGHT - player.h;
            if (player.x < 0) player.x = 0;
            if (player.x > WINDOW_WIDTH - player.w) player.x = WINDOW_WIDTH - player.w;

            if (state[SDL_SCANCODE_SPACE]) {
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].x = player.x + player.w;
                        bullets[i].y = player.y + player.h / 2;
                        bullets[i].active = true;
                        Mix_PlayChannel(-1, shotSound, 0);
                        break;
                    }
                }
            }

            for (int i = 0; i < MAX_BULLETS; i++) {
                if (bullets[i].active) {
                    bullets[i].x += BULLET_SPEED;
                    if (bullets[i].x > WINDOW_WIDTH) bullets[i].active = false;
                }
            }

            for (int i = 0; i < MAX_ENEMIES; i++) {
                if (enemies[i].active) {
                    enemies[i].x -= ENEMY_SPEED;
                    if (enemies[i].x < -enemies[i].rect.w) {
                        enemies[i].x = WINDOW_WIDTH + rand() % 200;
                        enemies[i].y = rand() % (WINDOW_HEIGHT - enemies[i].rect.h);
                    }
                    enemies[i].rect.x = enemies[i].x;
                    enemies[i].rect.y = enemies[i].y;
                }
            }

            Uint32 currentTicks = SDL_GetTicks();
            if (currentTicks - lastEnemyAnim > 150) {
                lastEnemyAnim = currentTicks;
                for (int i = 0; i < MAX_ENEMIES; i++) {
                    enemies[i].currentFrame = (enemies[i].currentFrame + 1) % NUM_FRAMES;
                }
            }

            for (int i = 0; i < MAX_BULLETS; i++) {
                if (!bullets[i].active)
                    continue;
                SDL_Rect bulletRect = {bullets[i].x, bullets[i].y, 10, 4};
                for (int j = 0; j < MAX_ENEMIES; j++) {
                    if (enemies[j].active && check_collision(bulletRect, enemies[j].rect)) {
                        enemies[j].active = false;
                        bullets[i].active = false;
                        score++;
                        Mix_PlayChannel(-1, explosionSound, 0);
                        break;
                    }
                }
            }

            for (int i = 0; i < MAX_ENEMIES; i++) {
                if (!enemies[i].active) {
                    enemies[i].x = WINDOW_WIDTH + rand() % 300;
                    enemies[i].y = rand() % (WINDOW_HEIGHT - enemies[i].rect.h);
                    enemies[i].active = true;
                    enemies[i].rect.x = enemies[i].x;
                    enemies[i].rect.y = enemies[i].y;
                    enemies[i].currentFrame = 0;
                }
            }

            backgroundX -= 2;
            if (backgroundX <= -WINDOW_WIDTH)
                backgroundX = 0;
        }

        SDL_SetRenderDrawColor(renderer, 0, 0, 50, 255);
        SDL_RenderClear(renderer);

        SDL_Rect bg1 = {backgroundX, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
        SDL_Rect bg2 = {backgroundX + WINDOW_WIDTH, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
        SDL_SetRenderDrawColor(renderer, 20, 20, 80, 255);
        SDL_RenderFillRect(renderer, &bg1);
        SDL_RenderFillRect(renderer, &bg2);

        if (gameState == MENU) {
            render_text(renderer, font, "Mini Afterburner Neo Geo Style", 150, 100);
            render_text(renderer, font, "Press Enter to Play", 280, 200);
            render_text(renderer, font, "Press O for Options", 280, 250);
            render_text(renderer, font, "Press Escape to Quit", 280, 300);
        } else if (gameState == OPTIONS) {
            char buf[64];
            sprintf(buf, "Music Volume: %d (Up/Down)", musicVolume);
            render_text(renderer, font, buf, 250, 150);
            sprintf(buf, "Effects Volume: %d (Left/Right)", effectsVolume);
            render_text(renderer, font, buf, 250, 200);
            render_text(renderer, font, "Press Escape to Return", 250, 300);
        } else if (gameState == PLAYING) {
            Uint32 currentTicks = SDL_GetTicks();
            SDL_Rect srcPlayerRect = {((currentTicks / 100) % NUM_FRAMES) * SPRITE_WIDTH, 0, SPRITE_WIDTH, SPRITE_HEIGHT};
            SDL_Rect destPlayerRect = {player.x, player.y, SPRITE_WIDTH, SPRITE_HEIGHT};
            SDL_RenderCopy(renderer, playerTexture, &srcPlayerRect, &destPlayerRect);

            SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255);
            for (int i = 0; i < MAX_BULLETS; i++) {
                if (bullets[i].active) {
                    SDL_Rect b = {bullets[i].x, bullets[i].y, 10, 4};
                    SDL_RenderFillRect(renderer, &b);
                }
            }

            for (int i = 0; i < MAX_ENEMIES; i++) {
                if (enemies[i].active) {
                    SDL_Rect srcEnemyRect = {enemies[i].currentFrame * SPRITE_WIDTH, 0, SPRITE_WIDTH, SPRITE_HEIGHT};
                    SDL_RenderCopy(renderer, enemyTexture, &srcEnemyRect, &(enemies[i].rect));
                }
            }

            char scoreText[32];
            sprintf(scoreText, "Score: %d", score);
            render_text(renderer, font, scoreText, 10, 10);
        }

        SDL_RenderPresent(renderer);
        SDL_Delay(16);
    }

    Mix_HaltMusic();
    Mix_FreeChunk(shotSound);
    Mix_FreeChunk(explosionSound);
    Mix_FreeMusic(music);
    Mix_CloseAudio();
    TTF_CloseFont(font);
    TTF_Quit();
    SDL_DestroyTexture(playerTexture);
    SDL_DestroyTexture(enemyTexture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}

void init_enemies(Enemy enemies[]) {
    for (int i = 0; i < MAX_ENEMIES; i++) {
        enemies[i].x = WINDOW_WIDTH + i * 150;
        enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
        enemies[i].active = true;
        enemies[i].rect = (SDL_Rect){enemies[i].x, enemies[i].y, SPRITE_WIDTH, SPRITE_HEIGHT};
        enemies[i].currentFrame = 0;
    }
}

bool check_collision(SDL_Rect a, SDL_Rect b) {
    return SDL_HasIntersection(&a, &b);
}

bool render_text(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y) {
    if (!renderer || !font || !text) return false;
    SDL_Color white = {255, 255, 255, 255};
    SDL_Surface* surfaceMessage = TTF_RenderText_Solid(font, text, white);
    if (!surfaceMessage) {
        SDL_Log("TTF_RenderText_Solid failed: %s", TTF_GetError());
        return false;
    }
    SDL_Texture* message = SDL_CreateTextureFromSurface(renderer, surfaceMessage);
    if (!message) {
        SDL_Log("SDL_CreateTextureFromSurface failed: %s", SDL_GetError());
        SDL_FreeSurface(surfaceMessage);
        return false;
    }
    SDL_Rect messageRect = {x, y, surfaceMessage->w, surfaceMessage->h};
    SDL_FreeSurface(surfaceMessage);
    SDL_RenderCopy(renderer, message, NULL, &messageRect);
    SDL_DestroyTexture(message);
    return true;
}
