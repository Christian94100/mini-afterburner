/*
 * Mini Afterburner â€“ cleaned version
 * Build: make
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include <time.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>

/* ---------- config ---------- */
#define WINDOW_WIDTH   800
#define WINDOW_HEIGHT  600
#define PLAYER_SPEED   350.0f   /* px/s */
#define BULLET_SPEED   600.0f
#define FIRE_COOLDOWN  0.18f    /* s */
#define MAX_BULLETS    10
#define MAX_ENEMIES    5
#define ENEMY_SPEED    180.0f
#define SPRITE_WIDTH   50
#define SPRITE_HEIGHT  30
#define NUM_FRAMES     4
#define MAX_PARTICLES  20
#define ASSET_PATH     "assets/"

typedef enum { MENU, OPTIONS, PLAYING, QUIT } GameState;

/* ---------- structs ---------- */
typedef struct { float x, y; bool active; } Bullet;
typedef struct { float x, y; bool active; SDL_Rect rect; int frame; } Enemy;
typedef struct { float x, y, dx, dy; uint8_t life; } Particle;

typedef struct {
    SDL_Window   *win;
    SDL_Renderer *ren;
    SDL_Texture  *texPlayer, *texEnemy;
    TTF_Font     *font;
    Mix_Music    *music;
    Mix_Chunk    *sndShot, *sndExplode;
    GameState     state;
    SDL_Rect      player;
    Bullet        bullets[MAX_BULLETS];
    Enemy         enemies[MAX_ENEMIES];
    Particle      particles[MAX_PARTICLES];
    int           score, highscore;
    int           volMusic, volFX;
    float         backgroundX;
    uint32_t      lastEnemyFrame;
    /* timers */
    float         fireTimer;
    uint32_t      lastTicks;
} Game;

/* ---------- util ---------- */
static bool asset_exists(const char *file)
{
    SDL_RWops *rw = SDL_RWFromFile(file, "r");
    if (rw) SDL_RWclose(rw);
    return rw != NULL;
}

static bool load_texture(SDL_Renderer *ren, const char *file, SDL_Texture **out)
{
    char path[256];
    snprintf(path, sizeof(path), "%s%s", ASSET_PATH, file);
    if (!asset_exists(path)) { SDL_Log("Missing %s", path); return false; }
    SDL_Surface *surf = SDL_LoadBMP(path);
    if (!surf) return false;
    *out = SDL_CreateTextureFromSurface(ren, surf);
    SDL_FreeSurface(surf);
    return *out != NULL;
}

static bool load_highscore(int *dst)
{
    FILE *f = fopen("highscore.txt", "r");
    if (f) { fscanf(f, "%d", dst); fclose(f); return true; }
    return false;
}

static void save_highscore(int v)
{
    FILE *f = fopen("highscore.txt", "w");
    if (f) { fprintf(f, "%d", v); fclose(f); }
}

/* ---------- init ---------- */
static bool game_init(Game *g)
{
    memset(g, 0, sizeof(*g));
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) return false;
    if (TTF_Init() == -1) goto fail;
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) goto fail;

    g->win = SDL_CreateWindow("Mini Afterburner", SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, 0);
    if (!g->win) goto fail;
    g->ren = SDL_CreateRenderer(g->win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!g->ren) goto fail;

    if (!load_texture(g->ren, "player.bmp", &g->texPlayer)) goto fail;
    if (!load_texture(g->ren, "enemy.bmp", &g->texEnemy)) goto fail;

    char path[256];
    snprintf(path, sizeof(path), "%s%s", ASSET_PATH, "arial.ttf");
    g->font = TTF_OpenFont(path, 24);
    if (!g->font) goto fail;

    snprintf(path, sizeof(path), "%s%s", ASSET_PATH, "synthwave_loop.ogg");
    g->music = Mix_LoadMUS(path);
    snprintf(path, sizeof(path), "%s%s", ASSET_PATH, "laser_shot.wav");
    g->sndShot = Mix_LoadWAV(path);
    snprintf(path, sizeof(path), "%s%s", ASSET_PATH, "explosion.wav");
    g->sndExplode = Mix_LoadWAV(path);
    if (!g->music || !g->sndShot || !g->sndExplode) goto fail;

    srand((unsigned)time(NULL));
    g->state = MENU;
    g->player = (SDL_Rect){100, WINDOW_HEIGHT/2 - SPRITE_HEIGHT/2, SPRITE_WIDTH, SPRITE_HEIGHT};
    g->volMusic = g->volFX = MIX_MAX_VOLUME / 2;
    load_highscore(&g->highscore);
    Mix_VolumeMusic(g->volMusic);
    Mix_VolumeChunk(g->sndShot, g->volFX);
    Mix_VolumeChunk(g->sndExplode, g->volFX);
    Mix_PlayMusic(g->music, -1);

    /* enemies */
    for (int i = 0; i < MAX_ENEMIES; ++i) {
        g->enemies[i].x = WINDOW_WIDTH + i * 200 + rand() % 100;
        g->enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
        g->enemies[i].active = true;
        g->enemies[i].rect = (SDL_Rect){(int)g->enemies[i].x, (int)g->enemies[i].y, SPRITE_WIDTH, SPRITE_HEIGHT};
    }
    g->lastTicks = SDL_GetTicks();
    return true;

fail:
    SDL_Log("%s", SDL_GetError());
    return false;
}

/* ---------- input ---------- */
static void handle_event(Game *g, SDL_Event *ev)
{
    if (ev->type == SDL_KEYDOWN) {
        switch (g->state) {
        case MENU:
            if (ev->key.keysym.sym == SDLK_RETURN) g->state = PLAYING;
            else if (ev->key.keysym.sym == SDLK_o) g->state = OPTIONS;
            else if (ev->key.keysym.sym == SDLK_ESCAPE) g->state = QUIT;
            break;
        case OPTIONS:
            if (ev->key.keysym.sym == SDLK_UP)   { g->volMusic = SDL_min(g->volMusic + 8, MIX_MAX_VOLUME); Mix_VolumeMusic(g->volMusic); }
            if (ev->key.keysym.sym == SDLK_DOWN) { g->volMusic = SDL_max(g->volMusic - 8, 0);           Mix_VolumeMusic(g->volMusic); }
            if (ev->key.keysym.sym == SDLK_LEFT)  { g->volFX = SDL_max(g->volFX - 8, 0); Mix_VolumeChunk(g->sndShot, g->volFX); Mix_VolumeChunk(g->sndExplode, g->volFX); }
            if (ev->key.keysym.sym == SDLK_RIGHT) { g->volFX = SDL_min(g->volFX + 8, MIX_MAX_VOLUME); Mix_VolumeChunk(g->sndShot, g->volFX); Mix_VolumeChunk(g->sndExplode, g->volFX); }
            if (ev->key.keysym.sym == SDLK_ESCAPE) g->state = MENU;
            break;
        case PLAYING:
            if (ev->key.keysym.sym == SDLK_ESCAPE) g->state = MENU;
            break;
        default: break;
        }
    }
}

/* ---------- update ---------- */
static void update(Game *g, float dt)
{
    if (g->state != PLAYING) return;

    const Uint8 *kb = SDL_GetKeyboardState(NULL);
    /* player movement */
    if (kb[SDL_SCANCODE_UP])    g->player.y -= PLAYER_SPEED * dt;
    if (kb[SDL_SCANCODE_DOWN])  g->player.y += PLAYER_SPEED * dt;
    if (kb[SDL_SCANCODE_LEFT])  g->player.x -= PLAYER_SPEED * dt;
    if (kb[SDL_SCANCODE_RIGHT]) g->player.x += PLAYER_SPEED * dt;
    g->player.y = SDL_clamp(g->player.y, 0, WINDOW_HEIGHT - g->player.h);
    g->player.x = SDL_clamp(g->player.x, 0, WINDOW_WIDTH  - g->player.w);

    /* shooting with cooldown */
    g->fireTimer -= dt;
    if (kb[SDL_SCANCODE_SPACE] && g->fireTimer <= 0) {
        for (int i = 0; i < MAX_BULLETS; ++i) {
            if (!g->bullets[i].active) {
                g->bullets[i].x = g->player.x + g->player.w;
                g->bullets[i].y = g->player.y + g->player.h * 0.5f;
                g->bullets[i].active = true;
                Mix_PlayChannel(-1, g->sndShot, 0);
                g->fireTimer = FIRE_COOLDOWN;
                break;
            }
        }
    }
    /* bullets */
    for (int i = 0; i < MAX_BULLETS; ++i) {
        if (g->bullets[i].active) {
            g->bullets[i].x += BULLET_SPEED * dt;
            if (g->bullets[i].x > WINDOW_WIDTH) g->bullets[i].active = false;
        }
    }
    /* enemies */
    uint32_t now = SDL_GetTicks();
    for (int i = 0; i < MAX_ENEMIES; ++i) {
        Enemy *e = &g->enemies[i];
        if (!e->active) continue;
        e->x -= ENEMY_SPEED * dt;
        if (e->x < -SPRITE_WIDTH) {
            e->x = WINDOW_WIDTH + rand() % 300;
            e->y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
        }
        e->rect.x = (int)e->x; e->rect.y = (int)e->y;
        /* animation */
        if (now - g->lastEnemyFrame > 150) {
            e->frame = (e->frame + 1) % NUM_FRAMES;
        }
    }
    if (now - g->lastEnemyFrame > 150) g->lastEnemyFrame = now;

    /* collisions */
    for (int i = 0; i < MAX_BULLETS; ++i) {
        if (!g->bullets[i].active) continue;
        SDL_Rect b = {(int)g->bullets[i].x, (int)g->bullets[i].y, 10, 4};
        for (int j = 0; j < MAX_ENEMIES; ++j) {
            Enemy *e = &g->enemies[j];
            if (e->active && SDL_HasIntersection(&b, &e->rect)) {
                e->active = false;
                g->bullets[i].active = false;
                g->score++;
                Mix_PlayChannel(-1, g->sndExplode, 0);
                /* spawn particles */
                for (int p = 0; p < MAX_PARTICLES; ++p) {
                    if (g->particles[p].life == 0) {
                        g->particles[p].x = e->rect.x + e->rect.w/2;
                        g->particles[p].y = e->rect.y + e->rect.h/2;
                        g->particles[p].dx = (float)(rand()%11-5);
                        g->particles[p].dy = (float)(rand()%11-5);
                        g->particles[p].life = 30;
                        break;
                    }
                }
                break;
            }
        }
    }
    /* respawn enemy */
    for (int i = 0; i < MAX_ENEMIES; ++i) {
        Enemy *e = &g->enemies[i];
        if (!e->active) {
            e->x = WINDOW_WIDTH + rand() % 300;
            e->y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
            e->active = true;
            e->rect.x = (int)e->x; e->rect.y = (int)e->y;
        }
    }
    /* player collision */
    for (int i = 0; i < MAX_ENEMIES; ++i) {
        if (g->enemies[i].active && SDL_HasIntersection(&g->player, &g->enemies[i].rect)) {
            g->state = MENU;
            if (g->score > g->highscore) { g->highscore = g->score; save_highscore(g->highscore); }
            g->score = 0;
            Mix_PlayChannel(-1, g->sndExplode, 0);
            break;
        }
    }
    /* particles */
    for (int i = 0; i < MAX_PARTICLES; ++i) {
        Particle *p = &g->particles[i];
        if (p->life) {
            p->x += p->dx; p->y += p->dy; p->life--;
        }
    }
    /* scrolling background */
    g->backgroundX -= 120.0f * dt;
    if (g->backgroundX <= -WINDOW_WIDTH) g->backgroundX += WINDOW_WIDTH;
}

/* ---------- render ---------- */
static void render_text(SDL_Renderer *ren, TTF_Font *f, const char *txt, int x, int y)
{
    SDL_Color white = {255,255,255,255};
    SDL_Surface *surf = TTF_RenderText_Solid(f, txt, white);
    if (!surf) return;
    SDL_Texture *tex = SDL_CreateTextureFromSurface(ren, surf);
    SDL_Rect dst = {x, y, surf->w, surf->h};
    SDL_RenderCopy(ren, tex, NULL, &dst);
    SDL_DestroyTexture(tex); SDL_FreeSurface(surf);
}

static void render(Game *g)
{
    SDL_SetRenderDrawColor(g->ren, 0, 0, 50, 255);
    SDL_RenderClear(g->ren);

    /* scrolling bg */
    SDL_SetRenderDrawColor(g->ren, 20, 20, 80, 255);
    SDL_Rect bg1 = {(int)g->backgroundX, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    SDL_Rect bg2 = {(int)(g->backgroundX + WINDOW_WIDTH), 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    SDL_RenderFillRect(g->ren, &bg1); SDL_RenderFillRect(g->ren, &bg2);

    if (g->state == MENU) {
        render_text(g->ren, g->font, "Mini Afterburner Neo Geo Style", 150, 100);
        render_text(g->ren, g->font, "Enter = Play   O = Options   Esc = Quit", 200, 200);
        char hs[32]; snprintf(hs, sizeof(hs), "Highscore %d", g->highscore);
        render_text(g->ren, g->font, hs, 300, 300);
    } else if (g->state == OPTIONS) {
        char buf[64];
        snprintf(buf, sizeof(buf), "Music  : %d  (Up/Down)", g->volMusic);
        render_text(g->ren, g->font, buf, 250, 150);
        snprintf(buf, sizeof(buf), "Effects: %d  (Left/Right)", g->volFX);
        render_text(g->ren, g->font, buf, 250, 200);
        render_text(g->ren, g->font, "Esc = Back", 250, 300);
    } else if (g->state == PLAYING) {
        /* player */
        SDL_Rect src = {(SDL_GetTicks()/100 % NUM_FRAMES)*SPRITE_WIDTH, 0, SPRITE_WIDTH, SPRITE_HEIGHT};
        SDL_RenderCopy(g->ren, g->texPlayer, &src, &g->player);
        /* bullets */
        SDL_SetRenderDrawColor(g->ren, 255, 255, 0, 255);
        for (int i = 0; i < MAX_BULLETS; ++i) {
            if (g->bullets[i].active) {
                SDL_Rect b = {(int)g->bullets[i].x, (int)g->bullets[i].y, 10, 4};
                SDL_RenderFillRect(g->ren, &b);
            }
        }
        /* enemies */
        for (int i = 0; i < MAX_ENEMIES; ++i) {
            Enemy *e = &g->enemies[i];
            if (e->active) {
                SDL_Rect srcE = {e->frame*SPRITE_WIDTH, 0, SPRITE_WIDTH, SPRITE_HEIGHT};
                SDL_RenderCopy(g->ren, g->texEnemy, &srcE, &e->rect);
            }
        }
        /* particles */
        SDL_SetRenderDrawColor(g->ren, 255, 140, 0, 255);
        for (int i = 0; i < MAX_PARTICLES; ++i) {
            Particle *p = &g->particles[i];
            if (p->life) { SDL_Rect pr = {(int)p->x, (int)p->y, 4, 4}; SDL_RenderFillRect(g->ren, &pr); }
        }
        /* score */
        char tmp[32]; snprintf(tmp, sizeof(tmp), "Score %d", g->score);
        render_text(g->ren, g->font, tmp, 10, 10);
    }
    SDL_RenderPresent(g->ren);
}

/* ---------- main ---------- */
int main(int argc, char **argv)
{
    (void)argc; (void)argv;
    Game g = {0};
    if (!game_init(&g)) return 1;

    bool running = true;
    SDL_Event ev;
    while (running && g.state != QUIT) {
        uint32_t now = SDL_GetTicks();
        float dt = (now - g.lastTicks) / 1000.0f;
        g.lastTicks = now;

        while (SDL_PollEvent(&ev)) {
            if (ev.type == SDL_QUIT) running = false;
            else handle_event(&g, &ev);
        }
        update(&g, dt);
        render(&g);
        SDL_Delay(1);               /* laisse respirer le CPU */
    }

    /* ---------- cleanup ---------- */
    Mix_HaltMusic();
    Mix_FreeChunk(g.sndExplode);
    Mix_FreeChunk(g.sndShot);
    Mix_FreeMusic(g.music);
    TTF_CloseFont(g.font);
    SDL_DestroyTexture(g.texEnemy);
    SDL_DestroyTexture(g.texPlayer);
    SDL_DestroyRenderer(g.ren);
    SDL_DestroyWindow(g.win);
    Mix_CloseAudio();
    TTF_Quit();
    SDL_Quit();
    return 0;
}




