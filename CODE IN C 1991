#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
#define PLAYER_SPEED 5
#define BULLET_SPEED 10
#define MAX_BULLETS 10
#define MAX_ENEMIES 5
#define ENEMY_SPEED 3
#define SPRITE_WIDTH 50
#define SPRITE_HEIGHT 30
#define NUM_FRAMES 4
#define MAX_PARTICLES 20

typedef enum { MENU, OPTIONS, PLAYING, QUIT } GameState;

typedef struct { int x, y; bool active; } Bullet;
typedef struct { int x, y; bool active; SDL_Rect rect; int currentFrame; } Enemy;
typedef struct { int x, y, dx, dy; Uint8 life; } Particle;

void init_enemies(Enemy enemies[]) {
    for (int i = 0; i < MAX_ENEMIES; i++) {
        enemies[i].x = WINDOW_WIDTH + i * 200 + rand() % 100;
        enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
        enemies[i].active = true;
        enemies[i].rect = (SDL_Rect){enemies[i].x, enemies[i].y, SPRITE_WIDTH, SPRITE_HEIGHT};
        enemies[i].currentFrame = 0;
    }
}

bool check_collision(SDL_Rect a, SDL_Rect b) {
    return SDL_HasIntersection(&a, &b);
}

bool render_text(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y) {
    if (!renderer || !font || !text) return false;
    SDL_Color white = {255, 255, 255, 255};
    SDL_Surface* surface = TTF_RenderText_Solid(font, text, white);
    if (!surface) return false;
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    if (!texture) { SDL_FreeSurface(surface); return false; }
    SDL_Rect dst = {x, y, surface->w, surface->h};
    SDL_RenderCopy(renderer, texture, NULL, &dst);
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
    return true;
}

void cleanup_resources(SDL_Window* window, SDL_Renderer* renderer, SDL_Texture* playerTex, 
                      SDL_Texture* enemyTex, TTF_Font* font, Mix_Music* music,
                      Mix_Chunk* shot, Mix_Chunk* explosion) {
    Mix_HaltMusic();
    if (shot) Mix_FreeChunk(shot);
    if (explosion) Mix_FreeChunk(explosion);
    if (music) Mix_FreeMusic(music);
    if (font) TTF_CloseFont(font);
    if (enemyTex) SDL_DestroyTexture(enemyTex);
    if (playerTex) SDL_DestroyTexture(playerTex);
    if (renderer) SDL_DestroyRenderer(renderer);
    if (window) SDL_DestroyWindow(window);
    Mix_CloseAudio();
    TTF_Quit();
    SDL_Quit();
}

int main(int argc, char *argv[]) {
    (void)argc; (void)argv;
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) { SDL_Log("SDL init failed"); return 1; }
    if (TTF_Init() == -1) { SDL_Log("TTF init failed"); SDL_Quit(); return 1; }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        SDL_Log("Audio init failed"); TTF_Quit(); SDL_Quit(); return 1;
    }

    SDL_Window *window = SDL_CreateWindow("Mini Afterburner", SDL_WINDOWPOS_CENTERED,
                                        SDL_WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, 0);
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | 
                                              SDL_RENDERER_PRESENTVSYNC);
    
    SDL_Surface *tmpSurf = SDL_LoadBMP("player.bmp");
    SDL_Texture *playerTexture = SDL_CreateTextureFromSurface(renderer, tmpSurf);
    SDL_FreeSurface(tmpSurf);
    tmpSurf = SDL_LoadBMP("enemy.bmp");
    SDL_Texture *enemyTexture = SDL_CreateTextureFromSurface(renderer, tmpSurf);
    SDL_FreeSurface(tmpSurf);

    TTF_Font *font = TTF_OpenFont("arial.ttf", 24);
    Mix_Music *music = Mix_LoadMUS("synthwave_loop.ogg");
    Mix_Chunk *shotSound = Mix_LoadWAV("laser_shot.wav");
    Mix_Chunk *explosionSound = Mix_LoadWAV("explosion.wav");

    if (!window || !renderer || !playerTexture || !enemyTexture || !font || !music || 
        !shotSound || !explosionSound) {
        cleanup_resources(window, renderer, playerTexture, enemyTexture, font, music,
                         shotSound, explosionSound);
        return 1;
    }

    srand((unsigned int)time(NULL));
    int musicVolume = MIX_MAX_VOLUME / 2, effectsVolume = MIX_MAX_VOLUME / 2;
    Mix_VolumeMusic(musicVolume);
    Mix_VolumeChunk(shotSound, effectsVolume);
    Mix_VolumeChunk(explosionSound, effectsVolume);

    GameState gameState = MENU;
    SDL_Rect player = {100, WINDOW_HEIGHT/2 - SPRITE_HEIGHT/2, SPRITE_WIDTH, SPRITE_HEIGHT};
    Bullet bullets[MAX_BULLETS] = {0};
    Enemy enemies[MAX_ENEMIES];
    Particle particles[MAX_PARTICLES] = {0};
    init_enemies(enemies);

    int score = 0, highscore = 0, backgroundX = 0;
    FILE *f = fopen("highscore.txt", "r");
    if (f) { fscanf(f, "%d", &highscore); fclose(f); }

    Mix_PlayMusic(music, -1);
    bool running = true;
    SDL_Event event;
    Uint32 lastEnemyAnim = SDL_GetTicks();

    while (running) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) running = false;
            else if (event.type == SDL_KEYDOWN) {
                switch(gameState) {
                    case MENU:
                        if (event.key.keysym.sym == SDLK_RETURN) gameState = PLAYING;
                        else if (event.key.keysym.sym == SDLK_o) gameState = OPTIONS;
                        else if (event.key.keysym.sym == SDLK_ESCAPE) running = false;
                        break;
                    case OPTIONS:
                        if (event.key.keysym.sym == SDLK_UP) 
                            musicVolume = (musicVolume + 8 > MIX_MAX_VOLUME) ? 
                                         MIX_MAX_VOLUME : musicVolume + 8;
                        if (event.key.keysym.sym == SDLK_DOWN)
                            musicVolume = (musicVolume - 8 < 0) ? 0 : musicVolume - 8;
                        if (event.key.keysym.sym == SDLK_LEFT)
                            effectsVolume = (effectsVolume - 8 < 0) ? 0 : effectsVolume - 8;
                        if (event.key.keysym.sym == SDLK_RIGHT)
                            effectsVolume = (effectsVolume + 8 > MIX_MAX_VOLUME) ? 
                                           MIX_MAX_VOLUME : effectsVolume + 8;
                        Mix_VolumeMusic(musicVolume);
                        Mix_VolumeChunk(shotSound, effectsVolume);
                        Mix_VolumeChunk(explosionSound, effectsVolume);
                        if (event.key.keysym.sym == SDLK_ESCAPE) gameState = MENU;
                        break;
                    case PLAYING:
                        if (event.key.keysym.sym == SDLK_ESCAPE) gameState = MENU;
                        break;
                }
            }
        }

        if (gameState == PLAYING) {
            const Uint8 *state = SDL_GetKeyboardState(NULL);
            if (state[SDL_SCANCODE_UP]) player.y -= PLAYER_SPEED;
            if (state[SDL_SCANCODE_DOWN]) player.y += PLAYER_SPEED;
            if (state[SDL_SCANCODE_RIGHT]) player.x += PLAYER_SPEED;
            if (state[SDL_SCANCODE_LEFT]) player.x -= PLAYER_SPEED;

            player.y = (player.y < 0) ? 0 : (player.y > WINDOW_HEIGHT - player.h) ? 
                       WINDOW_HEIGHT - player.h : player.y;
            player.x = (player.x < 0) ? 0 : (player.x > WINDOW_WIDTH - player.w) ? 
                       WINDOW_WIDTH - player.w : player.x;

            if (state[SDL_SCANCODE_SPACE]) {
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].x = player.x + player.w;
                        bullets[i].y = player.y + player.h / 2;
                        bullets[i].active = true;
                        Mix_PlayChannel(-1, shotSound, 0);
                        break;
                    }
                }
            }

            for (int i = 0; i < MAX_BULLETS; i++) {
                if (bullets[i].active) {
                    bullets[i].x += BULLET_SPEED;
                    if (bullets[i].x > WINDOW_WIDTH) bullets[i].active = false;
                }
            }

            for (int i = 0; i < MAX_ENEMIES; i++) {
                if (enemies[i].active) {
                    enemies[i].x -= ENEMY_SPEED;
                    if (enemies[i].x < -SPRITE_WIDTH) {
                        enemies[i].x = WINDOW_WIDTH + rand() % 200;
                        enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
                    }
                    enemies[i].rect.x = enemies[i].x;
                    enemies[i].rect.y = enemies[i].y;
                }
            }

            Uint32 currentTicks = SDL_GetTicks();
            if (currentTicks - lastEnemyAnim > 150) {
                lastEnemyAnim = currentTicks;
                for (int i = 0; i < MAX_ENEMIES; i++)
                    if (enemies[i].active)
                        enemies[i].currentFrame = (enemies[i].currentFrame + 1) % NUM_FRAMES;
            }

            // === COLLISIONS + PARTICULES ===
            for (int i = 0; i < MAX_BULLETS; i++) {
                if (!bullets[i].active) continue;
                SDL_Rect bulletRect = {bullets[i].x, bullets[i].y, 10, 4};
                for (int j = 0; j < MAX_ENEMIES; j++) {
                    if (enemies[j].active && check_collision(bulletRect, enemies[j].rect)) {
                        enemies[j].active = false;
                        bullets[i].active = false;
                        score++;
                        Mix_PlayChannel(-1, explosionSound, 0);
                        for (int p = 0; p < MAX_PARTICLES; p++) {
                            if (particles[p].life == 0) {
                                particles[p].x = enemies[j].rect.x + 25;
                                particles[p].y = enemies[j].rect.y + 15;
                                particles[p].dx = (rand() % 11) - 5;
                                particles[p].dy = (rand() % 11) - 5;
                                particles[p].life = 30;
                                break;
                            }
                        }
                        break;
                    }
                }
            }

            // === RESPAWN ENEMIES ===
            for (int i = 0; i < MAX_ENEMIES; i++) {
                if (!enemies[i].active) {
                    enemies[i].x = WINDOW_WIDTH + rand() % 300;
                    enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
                    enemies[i].active = true;
                    enemies[i].rect.x = enemies[i].x;
                    enemies[i].rect.y = enemies[i].y;
                }
            }

            // === GAME OVER ===
            for (int i = 0; i < MAX_ENEMIES; i++) {
                if (enemies[i].active && check_collision(player, enemies[i].rect)) {
                    gameState = MENU;
                    if (score > highscore) {
                        highscore = score;
                        f = fopen("highscore.txt", "w");
                        if (f) { fprintf(f, "%d", highscore); fclose(f); }
                    }
                    score = 0;
                    Mix_PlayChannel(-1, explosionSound, 0);
                    break;
                }
            }

            // === UPDATE PARTICULES ===
            for (int p = 0; p < MAX_PARTICLES; p++) {
                if (particles[p].life > 0) {
                    particles[p].x += particles[p].dx;
                    particles[p].y += particles[p].dy;
                    particles[p].life--;
                }
            }

            backgroundX = (backgroundX - 2 <= -WINDOW_WIDTH) ? 0 : backgroundX - 2;
        }

        SDL_SetRenderDrawColor(renderer, 0, 0, 50, 255);
        SDL_RenderClear(renderer);

        SDL_Rect bg1 = {backgroundX, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
        SDL_Rect bg2 = {backgroundX + WINDOW_WIDTH, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
        SDL_SetRenderDrawColor(renderer, 20, 20, 80, 255);
        SDL_RenderFillRect(renderer, &bg1);
        SDL_RenderFillRect(renderer, &bg2);

        if (gameState == MENU) {
            render_text(renderer, font, "Mini Afterburner Neo Geo Style", 150, 100);
            render_text(renderer, font, "Press Enter to Play", 280, 200);
            render_text(renderer, font, "Press O for Options", 280, 250);
            render_text(renderer, font, "Press Escape to Quit", 280, 300);
            char hs[32]; sprintf(hs, "Highscore: %d", highscore);
            render_text(renderer, font, hs, 300, 350);
        } else if (gameState == OPTIONS) {
            char buf[64];
            sprintf(buf, "Music Volume: %d (Up/Down)", musicVolume);
            render_text(renderer, font, buf, 250, 150);
            sprintf(buf, "Effects Volume: %d (Left/Right)", effectsVolume);
            render_text(renderer, font, buf, 250, 200);
            render_text(renderer, font, "Press Escape to Return", 250, 300);
        } else if (gameState == PLAYING) {
            SDL_Rect srcPlayer = {((SDL_GetTicks() / 100) % NUM_FRAMES) * SPRITE_WIDTH, 
                                 0, SPRITE_WIDTH, SPRITE_HEIGHT};
            SDL_RenderCopy(renderer, playerTexture, &srcPlayer, &player);

            SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255);
            for (int i = 0; i < MAX_BULLETS; i++)
                if (bullets[i].active) {
                    SDL_Rect b = {bullets[i].x, bullets[i].y, 10, 4};
                    SDL_RenderFillRect(renderer, &b);
                }

            for (int i = 0; i < MAX_ENEMIES; i++)
                if (enemies[i].active) {
                    SDL_Rect src = {enemies[i].currentFrame * SPRITE_WIDTH, 0, 
                                  SPRITE_WIDTH, SPRITE_HEIGHT};
                    SDL_RenderCopy(renderer, enemyTexture, &src, &enemies[i].rect);
                }

            // === RENDU PARTICULES ===
            SDL_SetRenderDrawColor(renderer, 255, 140, 0, 255);
            for (int p = 0; p < MAX_PARTICLES; p++) {
                if (particles[p].life > 0) {
                    SDL_Rect pr = {particles[p].x, particles[p].y, 4, 4};
                    SDL_RenderFillRect(renderer, &pr);
                }
            }

            char scoreText[32]; sprintf(scoreText, "Score: %d", score);
            render_text(renderer, font, scoreText, 10, 10);
        }

        SDL_RenderPresent(renderer);
        SDL_Delay(16);
    }

    cleanup_resources(window, renderer, playerTexture, enemyTexture, font, music,
                     shotSound, explosionSound);
    return 0;
}
