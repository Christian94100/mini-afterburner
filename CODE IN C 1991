c

#include "game.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

static void init_enemies(Enemy enemies[]) {
    for (int i = 0; i < MAX_ENEMIES; i++) {
        enemies[i].x = WINDOW_WIDTH + i * 200 + rand() % 100;
        enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
        enemies[i].active = true;
        enemies[i].rect = (SDL_Rect){enemies[i].x, enemies[i].y, SPRITE_WIDTH, SPRITE_HEIGHT};
        enemies[i].currentFrame = 0;
    }
}

static bool check_collision(SDL_Rect a, SDL_Rect b) {
    return SDL_HasIntersection(&a, &b);
}

static bool render_text(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y) {
    if (!renderer || !font || !text) return false;
    SDL_Color white = {255, 255, 255, 255};
    SDL_Surface* surface = TTF_RenderText_Solid(font, text, white);
    if (!surface) return false;
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    if (!texture) { SDL_FreeSurface(surface); return false; }
    SDL_Rect dst = {x, y, surface->w, surface->h};
    SDL_RenderCopy(renderer, texture, NULL, &dst);
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
    return true;
}

bool game_init(Game* game) {
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) return false;
    if (TTF_Init() == -1) { SDL_Quit(); return false; }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        TTF_Quit(); SDL_Quit(); return false;
    }

    game->window = SDL_CreateWindow("Mini Afterburner", SDL_WINDOWPOS_CENTERED,
                                  SDL_WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, 0);
    if (!game->window) goto cleanup_sdl;

    game->renderer = SDL_CreateRenderer(game->window, -1, 
                                      SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!game->renderer) goto cleanup_window;

    SDL_Surface* tmpSurf = SDL_LoadBMP("assets/player.bmp");
    if (!tmpSurf) goto cleanup_renderer;
    game->playerTexture = SDL_CreateTextureFromSurface(game->renderer, tmpSurf);
    SDL_FreeSurface(tmpSurf);
    if (!game->playerTexture) goto cleanup_renderer;

    tmpSurf = SDL_LoadBMP("assets/enemy.bmp");
    if (!tmpSurf) goto cleanup_player;
    game->enemyTexture = SDL_CreateTextureFromSurface(game->renderer, tmpSurf);
    SDL_FreeSurface(tmpSurf);
    if (!game->enemyTexture) goto cleanup_enemy;

    game->font = TTF_OpenFont("assets/arial.ttf", 24);
    game->music = Mix_LoadMUS("assets/synthwave_loop.ogg");
    game->shotSound = Mix_LoadWAV("assets/laser_shot.wav");
    game->explosionSound = Mix_LoadWAV("assets/explosion.wav");

    if (!game->font || !game->music || !game->shotSound || !game->explosionSound)
        goto cleanup_assets;

    srand((unsigned int)time(NULL));
    game->state = MENU;
    game->player = (SDL_Rect){100, WINDOW_HEIGHT/2 - SPRITE_HEIGHT/2, SPRITE_WIDTH, SPRITE_HEIGHT};
    game->score = 0;
    game->highscore = 0;
    game->musicVolume = MIX_MAX_VOLUME / 2;
    game->effectsVolume = MIX_MAX_VOLUME / 2;
    game->backgroundX = 0;
    game->lastEnemyAnim = SDL_GetTicks();

    FILE* f = fopen("highscore.txt", "r");
    if (f) { fscanf(f, "%d", &game->highscore); fclose(f); }

    Mix_VolumeMusic(game->musicVolume);
    Mix_VolumeChunk(game->shotSound, game->effectsVolume);
    Mix_VolumeChunk(game->explosionSound, game->effectsVolume);

    init_enemies(game->enemies);
    Mix_PlayMusic(game->music, -1);

    return true;

cleanup_assets:
    if (game->explosionSound) Mix_FreeChunk(game->explosionSound);
    if (game->shotSound) Mix_FreeChunk(game->shotSound);
    if (game->music) Mix_FreeMusic(game->music);
    if (game->font) TTF_CloseFont(game->font);
cleanup_enemy:
    if (game->enemyTexture) SDL_DestroyTexture(game->enemyTexture);
cleanup_player:
    if (game->playerTexture) SDL_DestroyTexture(game->playerTexture);
cleanup_renderer:
    if (game->renderer) SDL_DestroyRenderer(game->renderer);
cleanup_window:
    if (game->window) SDL_DestroyWindow(game->window);
cleanup_sdl:
    Mix_CloseAudio(); TTF_Quit(); SDL_Quit();
    return false;
}

void game_handle_event(Game* game, SDL_Event* event) {
    if (event->type == SDL_KEYDOWN) {
        switch(game->state) {
            case MENU:
                if (event->key.keysym.sym == SDLK_RETURN) game->state = PLAYING;
                else if (event->key.keysym.sym == SDLK_o) game->state = OPTIONS;
                else if (event->key.keysym.sym == SDLK_ESCAPE) game->state = QUIT;
                break;
            case OPTIONS:
                if (event->key.keysym.sym == SDLK_UP) 
                    game->musicVolume = (game->musicVolume + 8 > MIX_MAX_VOLUME) ? 
                                       MIX_MAX_VOLUME : game->musicVolume + 8;
                if (event->key.keysym.sym == SDLK_DOWN)
                    game->musicVolume = (game->musicVolume - 8 < 0) ? 0 : game->musicVolume - 8;
                if (event->key.keysym.sym == SDLK_LEFT)
                    game->effectsVolume = (game->effectsVolume - 8 < 0) ? 0 : game->effectsVolume - 8;
                if (event->key.keysym.sym == SDLK_RIGHT)
                    game->effectsVolume = (effectsVolume + 8 > MIX_MAX_VOLUME) ? 
                                         MIX_MAX_VOLUME : game->effectsVolume + 8;
                Mix_VolumeMusic(game->musicVolume);
                Mix_VolumeChunk(game->shotSound, game->effectsVolume);
                Mix_VolumeChunk(game->explosionSound, game->effectsVolume);
                if (event->key.keysym.sym == SDLK_ESCAPE) game->state = MENU;
                break;
            case PLAYING:
                if (event->key.keysym.sym == SDLK_ESCAPE) game->state = MENU;
                break;
        }
    }
}

void game_update(Game* game) {
    if (game->state != PLAYING) return;

    const Uint8* state = SDL_GetKeyboardState(NULL);
    
    if (state[SDL_SCANCODE_UP]) game->player.y -= PLAYER_SPEED;
    if (state[SDL_SCANCODE_DOWN]) game->player.y += PLAYER_SPEED;
    if (state[SDL_SCANCODE_RIGHT]) game->player.x += PLAYER_SPEED;
    if (state[SDL_SCANCODE_LEFT]) game->player.x -= PLAYER_SPEED;

    game->player.y = (game->player.y < 0) ? 0 : 
                     (game->player.y > WINDOW_HEIGHT - game->player.h) ? 
                     WINDOW_HEIGHT - game->player.h : game->player.y;
    game->player.x = (game->player.x < 0) ? 0 : 
                     (game->player.x > WINDOW_WIDTH - game->player.w) ? 
                     WINDOW_WIDTH - game->player.w : game->player.x;

    if (state[SDL_SCANCODE_SPACE]) {
        for (int i = 0; i < MAX_BULLETS; i++) {
            if (!game->bullets[i].active) {
                game->bullets[i].x = game->player.x + game->player.w;
                game->bullets[i].y = game->player.y + game->player.h / 2;
                game->bullets[i].active = true;
                Mix_PlayChannel(-1, game->shotSound, 0);
                break;
            }
        }
    }

    for (int i = 0; i < MAX_BULLETS; i++) {
        if (game->bullets[i].active) {
            game->bullets[i].x += BULLET_SPEED;
            if (game->bullets[i].x > WINDOW_WIDTH) game->bullets[i].active = false;
        }
    }

    for (int i = 0; i < MAX_ENEMIES; i++) {
        if (game->enemies[i].active) {
            game->enemies[i].x -= ENEMY_SPEED;
            if (game->enemies[i].x < -SPRITE_WIDTH) {
                game->enemies[i].x = WINDOW_WIDTH + rand() % 200;
                game->enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
            }
            game->enemies[i].rect.x = game->enemies[i].x;
            game->enemies[i].rect.y = game->enemies[i].y;
        }
    }

    Uint32 currentTicks = SDL_GetTicks();
    if (currentTicks - game->lastEnemyAnim > 150) {
        game->lastEnemyAnim = currentTicks;
        for (int i = 0; i < MAX_ENEMIES; i++)
            if (game->enemies[i].active)
                game->enemies[i].currentFrame = (game->enemies[i].currentFrame + 1) % NUM_FRAMES;
    }

    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!game->bullets[i].active) continue;
        SDL_Rect bulletRect = {game->bullets[i].x, game->bullets[i].y, 10, 4};
        for (int j = 0; j < MAX_ENEMIES; j++) {
            if (game->enemies[j].active && check_collision(bulletRect, game->enemies[j].rect)) {
                game->enemies[j].active = false;
                game->bullets[i].active = false;
                game->score++;
                Mix_PlayChannel(-1, game->explosionSound, 0);
                for (int p = 0; p < MAX_PARTICLES; p++) {
                    if (game->particles[p].life == 0) {
                        game->particles[p].x = game->enemies[j].rect.x + 25;
                        game->particles[p].y = game->enemies[j].rect.y + 15;
                        game->particles[p].dx = (rand() % 11) - 5;
                        game->particles[p].dy = (rand() % 11) - 5;
                        game->particles[p].life = 30;
                        break;
                    }
                }
                break;
            }
        }
    }

    for (int i = 0; i < MAX_ENEMIES; i++) {
        if (!game->enemies[i].active) {
            game->enemies[i].x = WINDOW_WIDTH + rand() % 300;
            game->enemies[i].y = rand() % (WINDOW_HEIGHT - SPRITE_HEIGHT);
            game->enemies[i].active = true;
            game->enemies[i].rect.x = game->enemies[i].x;
            game->enemies[i].rect.y = game->enemies[i].y;
        }
    }

    for (int i = 0; i < MAX_ENEMIES; i++) {
        if (game->enemies[i].active && check_collision(game->player, game->enemies[i].rect)) {
            game->state = MENU;
            if (game->score > game->highscore) {
                game->highscore = game->score;
                FILE* f = fopen("highscore.txt", "w");
                if (f) { fprintf(f, "%d", game->highscore); fclose(f); }
            }
            game->score = 0;
            Mix_PlayChannel(-1, game->explosionSound, 0);
            break;
        }
    }

    for (int p = 0; p < MAX_PARTICLES; p++) {
        if (game->particles[p].life > 0) {
            game->particles[p].x += game->particles[p].dx;
            game->particles[p].y += game->particles[p].dy;
            game->particles[p].life--;
        }
    }

    game->backgroundX = (game->backgroundX - 2 <= -WINDOW_WIDTH) ? 0 : game->backgroundX - 2;
}

void game_render(Game* game) {
    SDL_SetRenderDrawColor(game->renderer, 0, 0, 50, 255);
    SDL_RenderClear(game->renderer);

    SDL_Rect bg1 = {game->backgroundX, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    SDL_Rect bg2 = {game->backgroundX + WINDOW_WIDTH, 0, WINDOW_WIDTH, WINDOW_HEIGHT}; // FIXED
    SDL_SetRenderDrawColor(game->renderer, 20, 20, 80, 255);
    SDL_RenderFillRect(game->renderer, &bg1);
    SDL_RenderFillRect(game->renderer, &bg2);

    if (game->state == MENU) {
        render_text(game->renderer, game->font, "Mini Afterburner Neo Geo Style", 150, 100);
        render_text(game->renderer, game->font, "Press Enter to Play", 280, 200);
        render_text(game->renderer, game->font, "Press O for Options", 280, 250);
        render_text(game->renderer, game->font, "Press Escape to Quit", 280, 300);
        char hs[32]; sprintf(hs, "Highscore: %d", game->highscore);
        render_text(game->renderer, game->font, hs, 300, 350);
    } 
    else if (game->state == OPTIONS) {
        char buf[64];
        sprintf(buf, "Music Volume: %d (Up/Down)", game->musicVolume);
        render_text(game->renderer, game->font, buf, 250, 150);
        sprintf(buf, "Effects Volume: %d (Left/Right)", game->effectsVolume);
        render_text(game->renderer, game->font, buf, 250, 200);
        render_text(game->renderer, game->font, "Press Escape to Return", 250, 300);
    }
    else if (game->state == PLAYING) {
        SDL_Rect srcPlayer = {((SDL_GetTicks() / 100) % NUM_FRAMES) * SPRITE_WIDTH, 
                             0, SPRITE_WIDTH, SPRITE_HEIGHT};
        SDL_RenderCopy(game->renderer, game->playerTexture, &srcPlayer, &game->player);

        SDL_SetRenderDrawColor(game->renderer, 255, 255, 0, 255);
        for (int i = 0; i < MAX_BULLETS; i++)
            if (game->bullets[i].active) {
                SDL_Rect b = {game->bullets[i].x, game->bullets[i].y, 10, 4};
                SDL_RenderFillRect(game->renderer, &b);
            }

        for (int i = 0; i < MAX_ENEMIES; i++)
            if (game->enemies[i].active) {
                SDL_Rect src = {game->enemies[i].currentFrame * SPRITE_WIDTH, 0, 
                              SPRITE_WIDTH, SPRITE_HEIGHT};
                SDL_RenderCopy(game->renderer, game->enemyTexture, &src, &game->enemies[i].rect);
            }

        SDL_SetRenderDrawColor(game->renderer, 255, 140, 0, 255);
        for (int p = 0; p < MAX_PARTICLES; p++) {
            if (game->particles[p].life > 0) {
                SDL_Rect pr = {game->particles[p].x, game->particles[p].y, 4, 4};
                SDL_RenderFillRect(game->renderer, &pr);
            }
        }

        char scoreText[32]; sprintf(scoreText, "Score: %d", game->score);
        render_text(game->renderer, game->font, scoreText, 10, 10);
    }

    SDL_RenderPresent(game->renderer);
}

void game_cleanup(Game* game) {
    Mix_HaltMusic();
    Mix_FreeChunk(game->shotSound);
    Mix_FreeChunk(game->explosionSound);
    Mix_FreeMusic(game->music);
    TTF_CloseFont(game->font);
    SDL_DestroyTexture(game->enemyTexture);
    SDL_DestroyTexture(game->playerTexture);
    SDL_DestroyRenderer(game->renderer);
    SDL_DestroyWindow(game->window);
    Mix_CloseAudio();
    TTF_Quit();
    SDL_Quit();
}

main.cc

#include "game.h"

int main(int argc, char *argv[]) {
    (void)argc; (void)argv;

    Game game = {0};
    if (!game_init(&game)) {
        SDL_Log("Game initialization failed: %s", SDL_GetError());
        return 1;
    }

    bool running = true;
    SDL_Event event;

    while (running && game.state != QUIT) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) running = false;
            else game_handle_event(&game, &event);
        }

        game_update(&game);
        game_render(&game);
        SDL_Delay(16);
    }

    game_cleanup(&game);
    return 0;
}



